# 闭包

理解闭包需要理解作用域链的概念。

当某个函数被调用时，会创建一个执行环境（execution context）及其相应的作用域链。然后使用 arguments 和其他命名参数的值初始化函数的活动对象（activation object）。

但在作用域链中，外部函数的活动对象始终处于作用域链的第二位，外部函数的外部函数的活动对象处于第三位，依此类推，直至作为作用域终点的全局执行环境。

## 什么是闭包

闭包是指有权访问另一个函数作用域内变量的函数。

简单来说：**闭包 = 函数 + 函数能够访问的自由变量**

自由变量：指在函数中使用的，既不是函数参数也不是函数局部变量的变量。

:::tip

由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，所以只在必要的时刻再考虑使用闭包。

虽然像V8等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但是还是需要谨慎使用闭包。

:::

## 闭包的内存泄漏

```javascript
function fn() {
    let num = 1
    function add() {
        num++
        console.log(num)
    }
    return add
 }

 const f = fn()
 f() // 2
 f() // 3
``` 
上面代码中，`num` 变量会存在内存泄漏。

借助于垃圾回收机制的标记清除法可以看出：

`f` 是一个全局变量，代码执行完毕之后并不会立即销毁，f 使用了 `fn` 函数， fn 用到了 `add` 函数， add 函数里用到了 `num` 变量，num 变量被引用就不会被回收，所以会一直存在。

此时，**闭包引起了内存泄漏**。

## 使用闭包的注意点

- 由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法：在函数退出之前，将不使用的局部变量全部删除。

- 闭包会在父函数外部改变父函数内部变量的值。所以，如果把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作他的私有变量（private value），这时一定要小心，不要随便改变父函数内部变量的值。

## 问题1:闭包一定会有return吗？

闭包 = 函数 + 函数能够访问的自由变量

```javascript
function f1() {
    const a = 1
    function f() {
        console.log(a)
    }
    f()
}
f1()
```
上面代码中，2-5 行即形成了一个闭包。通常会使用一个函数包住闭包结构，以起到对变量保护的作用。

**什么时候使用 return**

外部如果想要使用闭包的变量，就需要使用 return。


